The original test case create a child process to test
Sendfile system call. But, sgx-lkl environment supports single process.
Hence, the test case is modified to use pthread instead of a child
process.

diff --git a/testcases/kernel/syscalls/sendfile/sendfile02.c b/testcases/kernel/syscalls/sendfile/sendfile02.c
index e5f115146..08832748e 100644
--- a/testcases/kernel/syscalls/sendfile/sendfile02.c
+++ b/testcases/kernel/syscalls/sendfile/sendfile02.c
@@ -56,8 +56,10 @@
 #include <arpa/inet.h>
 #include <unistd.h>
 #include <inttypes.h>
+#include <pthread.h>
 #include "test.h"
 #include "safe_macros.h"
+#include "tst_safe_pthread.h"
 
 #ifndef OFF_T
 #define OFF_T off_t
@@ -72,9 +74,10 @@ int out_fd;
 pid_t child_pid;
 static int sockfd, s;
 static struct sockaddr_in sin1;	/* shared between do_child and create_server */
+pthread_t ptid;
 
 void cleanup(void);
-void do_child(void);
+void* do_child(void* parm);
 void setup(void);
 int create_server(void);
 
@@ -99,8 +102,6 @@ void do_sendfile(OFF_T offset, int i)
 {
 	int in_fd;
 	struct stat sb;
-	int wait_status;
-	int wait_stat;
 	off_t before_pos, after_pos;
 
 	out_fd = create_server();
@@ -130,7 +131,7 @@ void do_sendfile(OFF_T offset, int i)
 			 "expected value, expected: %d, "
 			 "got: %ld", testcases[i].exp_retval,
 			 TEST_RETURN);
-		kill(child_pid, SIGKILL);
+		pthread_cancel(ptid);
 	} else if (offset != testcases[i].exp_updated_offset) {
 		tst_resm(TFAIL, "sendfile(2) failed to update "
 			 "OFFSET parameter to expected value, "
@@ -145,7 +146,7 @@ void do_sendfile(OFF_T offset, int i)
 	} else {
 		tst_resm(TPASS, "functionality of sendfile() is "
 			 "correct");
-		wait_status = waitpid(-1, &wait_stat, 0);
+		SAFE_PTHREAD_JOIN(ptid, NULL);
 	}
 
 	close(in_fd);
@@ -154,18 +155,16 @@ void do_sendfile(OFF_T offset, int i)
 /*
  * do_child
  */
-void do_child(void)
+void* do_child(void* parm LTP_ATTRIBUTE_UNUSED)
 {
-	int lc;
 	socklen_t length;
 	char rbuf[4096];
 
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		length = sizeof(sin1);
-		recvfrom(sockfd, rbuf, 4096, 0, (struct sockaddr *)&sin1,
-			 &length);
-	}
-	exit(0);
+	length = sizeof(sin1);
+	recvfrom(sockfd, rbuf, 4096, 0, (struct sockaddr *)&sin1,
+		 &length);
+
+	pthread_exit(0);
 }
 
 /*
@@ -202,6 +201,7 @@ void setup(void)
 void cleanup(void)
 {
 
+	close(sockfd);
 	close(out_fd);
 	/* delete the test directory created in setup() */
 	tst_rmdir();
@@ -230,23 +230,7 @@ int create_server(void)
 	}
 	SAFE_GETSOCKNAME(cleanup, sockfd, (struct sockaddr *)&sin1, &slen);
 
-	child_pid = FORK_OR_VFORK();
-	if (child_pid < 0) {
-		tst_brkm(TBROK, cleanup, "client/server fork failed: %s",
-			 strerror(errno));
-		return -1;
-	}
-	if (!child_pid) {	/* child */
-#ifdef UCLINUX
-		if (self_exec(argv0, "") < 0) {
-			tst_brkm(TBROK, cleanup, "self_exec failed");
-			return -1;
-
-		}
-#else
-		do_child();
-#endif
-	}
+	SAFE_PTHREAD_CREATE(&ptid, NULL, do_child, NULL);
 
 	s = socket(PF_INET, SOCK_DGRAM, 0);
 	inet_aton("127.0.0.1", &sin1.sin_addr);
