diff --git a/testcases/kernel/syscalls/setsid/setsid01.c b/testcases/kernel/syscalls/setsid/setsid01.c
index ed8f0e4ad..67f086ad7 100644
--- a/testcases/kernel/syscalls/setsid/setsid01.c
+++ b/testcases/kernel/syscalls/setsid/setsid01.c
@@ -39,6 +39,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "test.h"
+#include <pthread.h>
 
 #define INVAL_FLAG	-1
 #define USER2		301
@@ -53,161 +54,113 @@ int TST_TOTAL = 1;
 static char *argv0;
 #endif
 
-void do_child_1(void);
-void do_child_2(void);
 void setup(void);
 void cleanup(void);
 
+static void* do_child_thread(void* arg);
+static void* do_master_thread(void* arg);
+
+
 int main(int ac, char **av)
 {
-	int pid;
-	int fail = 0;
-	int ret, status;
-	int exno = 0;
-
-	int lc;
+  int fail = 0;
+  int lc;
 
-	tst_parse_opts(ac, av, NULL, NULL);
+  tst_parse_opts(ac, av, NULL, NULL);
 #ifdef UCLINUX
-	argv0 = av[0];
+  argv0 = av[0];
 
-	maybe_run_child(&do_child_1, "n", 1);
-	maybe_run_child(&do_child_2, "n", 2);
+  maybe_run_child(&do_child_1, "n", 1);
+  maybe_run_child(&do_child_2, "n", 2);
 #endif
 
-	/*
-	 * perform global setup for the test
-	 */
-	setup();
-
-	for (lc = 0; TEST_LOOPING(lc); lc++) {
-
-		/* reset tst_count in case we are looping */
-		tst_count = 0;
+  /*
+   * perform global setup for the test
+   */
+  setup();
+
+  for (lc = 0; TEST_LOOPING(lc); lc++) {
+
+    /* reset tst_count in case we are looping */
+    tst_count = 0;
+
+    /*
+     * When the process group having forked of a child
+     * and then it attached itself to another process
+     * group and tries to setsid
+     */
+    int s;
+
+    pthread_t master_tid;
+
+    s = pthread_create(&master_tid, NULL, do_master_thread, NULL);
+
+    if (s == 0)
+    {
+      printf("%s(): thread created fine ...\n", __FUNCTION__);
+      pthread_join(master_tid, NULL);
+    }
+    else
+    {
+      printf("%s(): thread created error ...\n", __FUNCTION__);
+      tst_resm(TFAIL, "Pthread create failed");
+      fail = 1;
+    }
+
+    if (!fail) {
+      tst_resm(TPASS, "all misc tests passed");
+    }
+  }
+  cleanup();
+  tst_exit();
 
-		/*
-		 * When the process group having forked of a child
-		 * and then it attached itself to another process
-		 * group and tries to setsid
-		 */
-		pid = FORK_OR_VFORK();
-
-		if (pid == 0) {
-			if ((pid = FORK_OR_VFORK()) == -1) {
-				tst_resm(TFAIL, "Fork failed");
+}
 
-			}
-			if (pid == 0) {
-#ifdef UCLINUX
-				if (self_exec(argv0, "n", 1) < 0) {
-					tst_resm(TFAIL, "self_exec failed");
 
-				}
-#else
-				do_child_1();
-#endif
-			} else {
-				if (setpgid(0, 0) < 0) {
-					tst_resm(TFAIL,
-						 "setpgid(parent) failed: %s",
-						 strerror(errno));
-					fail = 1;
-				}
-
-				if ((ret = wait(&status)) > 0) {
-					if (status != 0) {
-						tst_resm(TFAIL,
-							 "Test {%d} exited "
-							 "status 0x%0x (wanted 0x0)",
-							 ret, status);
-						fail = 1;
-					}
-				}
-			}
-			exit(0);
-		} else {
-			if ((ret = wait(&status)) > 0) {
-				if (status != 0) {
-					tst_resm(TFAIL, "Test {%d} exited "
-						 "status 0x%0x (wanted 0x0)",
-						 ret, status);
-					fail = 1;
-				}
-			}
-		}
-
-		if (!(fail || exno)) {
-			tst_resm(TPASS, "all misc tests passed");
-		}
-	}
-	cleanup();
-	tst_exit();
+static void* do_master_thread(void* arg)
+{
+  int s;
+  pthread_t child_tid;
 
-}
+  setpgid(0,0);
 
-/*
- * do_child_1()
- */
-void do_child_1(void)
-{
-	int exno = 0;
-	int retval, ret, status;
-	int pid;
+  s = pthread_create(&child_tid, NULL, do_child_thread, NULL);
 
-	sleep(1);
+  if (s == 0)
+  {
+    printf("%s(): thread created fine ...\n", __FUNCTION__);
+    pthread_join(child_tid, NULL);
+  }
+  else
+    printf("%s(): thread created error ...\n", __FUNCTION__);
 
-	if (setpgid(0, 0) < 0) {
-		tst_resm(TFAIL, "setpgid(0,0) failed: %s", strerror(errno));
-		exno = 1;
-	}
+  pthread_exit(NULL);
 
-	if ((pid = FORK_OR_VFORK()) == -1) {
-		tst_brkm(TFAIL, NULL, "Fork failed");
-	}
-	if (pid == 0) {
-#ifdef UCLINUX
-		if (self_exec(argv0, "n", 2) < 0) {
-			tst_brkm(TFAIL, NULL, "self_exec failed");
-		}
-#else
-		do_child_2();
-#endif
-	} else {
-		retval = setpgid(0, getppid());
-		if (retval < 0) {
-			tst_resm(TFAIL, "setpgid failed, errno :%d", errno);
-			exno = 2;
-		}
-
-		retval = setsid();
-
-		if (errno == EPERM) {
-			tst_resm(TPASS, "setsid SUCCESS to set "
-				 "errno to EPERM");
-		} else {
-			tst_resm(TFAIL, "setsid failed, expected %d,"
-				 "return %d", -1, errno);
-			exno = 3;
-		}
-		kill(pid, SIGKILL);
-		if ((ret = wait(&status)) > 0) {
-			if (status != 9) {
-				tst_resm(TFAIL,
-					 "Test {%d} exited status 0x%-x (wanted 0x9)",
-					 ret, status);
-				exno = 4;
-			}
-		}
-	}
-	exit(exno);
 }
 
-/*
- * do_child_2()
- */
-void do_child_2(void)
+
+static void* do_child_thread(void* arg)
 {
-	for (;;) ;
+  int retval;
+
+  retval = setpgid(0, getppid());
+  
+  if (retval < 0) {
+    tst_resm(TFAIL, "setpgid failed, errno :%d", errno);
+  }
+
+  retval = setsid();
+
+  if (errno == EPERM) {
+    tst_resm(TPASS, "setsid SUCCESS to set "
+        "errno to EPERM");
+  } else {
+    tst_resm(TFAIL, "setsid failed, expected %d,"
+        "return %d", -1, errno);
+  }
+  
+  pthread_exit(NULL);
+
 }
 
 /*
