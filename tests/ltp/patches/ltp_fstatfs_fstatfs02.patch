diff --git a/testcases/kernel/syscalls/fstatfs/fstatfs02.c b/testcases/kernel/syscalls/fstatfs/fstatfs02.c
index db2230f82..385d846d0 100644
--- a/testcases/kernel/syscalls/fstatfs/fstatfs02.c
+++ b/testcases/kernel/syscalls/fstatfs/fstatfs02.c
@@ -20,6 +20,13 @@
  * DESCRIPTION
  *     Testcase to check fstatfs() sets errno correctly.
  */
+/*
+ * Patch Description: Here one test is trying to access invalid address,
+ * Process should get efault if it access invalid address
+ * But in sgx, enclave exits when process access invalid address, so application will not get control.
+ * Please refer git issue 169
+ * This cannot be tested now so commented the 2nd test and will enable the test once 169 is fixed.
+ */

 #include <sys/vfs.h>
 #include <sys/types.h>
@@ -42,13 +49,13 @@ static struct test_case_t {
 } TC[] = {
        /* EBADF - fd is invalid */
        {
-       -1, &buf, EBADF},
-#ifndef UCLINUX
+       -1, &buf, EBADF}
+//#ifndef UCLINUX
            /* Skip since uClinux does not implement memory protection */
            /* EFAULT - address for buf is invalid */
-       {
-       -1, (void *)-1, EFAULT}
-#endif
+//     {
+//     -1, (void *)-1, EFAULT} TODO: Analyze and enable once issue 169 is fixed.
+//#endif
 };

 int TST_TOTAL = ARRAY_SIZE(TC);
@@ -98,17 +105,17 @@ static void setup(void)
        TEST_PAUSE;

        tst_tmpdir();
-#ifndef UCLINUX
-       TC[1].fd = SAFE_OPEN(cleanup, "tempfile", O_RDWR | O_CREAT, 0700);
-#endif
+//#ifndef UCLINUX
+//     TC[1].fd = SAFE_OPEN(cleanup, "tempfile", O_RDWR | O_CREAT, 0700);
+//#endif
 }

 static void cleanup(void)
 {
-#ifndef UCLINUX
-       if (TC[1].fd > 0 && close(TC[1].fd))
-               tst_resm(TWARN | TERRNO, "Failed to close fd");
-#endif
+//#ifndef UCLINUX
+//     if (TC[1].fd > 0 && close(TC[1].fd))
+//             tst_resm(TWARN | TERRNO, "Failed to close fd");
+//#endif

        tst_rmdir();
 }

